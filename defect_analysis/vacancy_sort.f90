program vacancy_sort

! reads the "fort.20" list of tetrahedra generated by gettet.x
! and reads poscart.out, in combination with the "fort.41" list of
! tetrahedral occupiations to produce a z-sliced time average of 
! vacant Td sites

implicit none

type thision
    double precision, dimension(3) :: r
    integer :: tet
end type thision

type tetrahedron
    type(thision), dimension(4) :: ion 
    integer, dimension(4) :: num
    double precision, dimension(3) :: centre
    integer :: occupied
    integer :: occold
    integer :: occref
    integer :: occdum
end type tetrahedron

type(thision), allocatable, dimension(:) :: ion
type(tetrahedron), allocatable, dimension(:) :: tetra
character(len=20) :: inptfile
character(len=20) :: tetlistf
character(len=20) :: tetoccf
character(len=20) :: posfile
character(len=20) :: fmtin
integer :: nbins, ntet, nions, nfions, ncoords
double precision :: maxz
integer :: i, j, k, l, dum
integer, allocatable, dimension(:,:) :: zbin
integer :: thisbin, kstart
double precision, dimension(3) :: boxlen, hboxlen
double precision :: tetspread
double precision, dimension(3) :: r1, r2, r3, r4
logical :: vaclog
double precision :: vaccent
character(len=1) :: zdir
integer :: zindex
integer :: nskip
integer :: nvac1, nvac2, nocc1, nocc2
character(len=20) :: outfile1, outfile2, outfile3
logical :: dynflag ! only consider defects if present for sequential frames

inptfile = "vacancy_sort.inpt"
outfile1 = "vacancynum.dat"
outfile2 = "vacancydist.dat"
outfile3 = "vaccentpos.dat"

open(99, file=outfile1)
open(29, file=outfile2)
open(60, file=outfile3)
open(10, file=inptfile, status="old")

read(10,'(a)') posfile
read(10,*) ncoords
read(10,*) nions
read(10,*) nfions
read(10,*) tetlistf
read(10,*) ntet
read(10,*) maxz
read(10,*) nbins
read(10,*) tetoccf
read(10,*) boxlen(1:3)
read(10,*) zdir
read(10,*) dynflag
if (dynflag) then
    read(10,*) nskip
else
    nskip = 0
endif
read(10,*) vaclog
if (vaclog) then
    read(10,*) vaccent
endif

select case (zdir)
    case ("x")
        zindex = 1
    case ("y")
        zindex = 2
    case ("z")
        zindex = 3
    case default
        write(6,*) "Invalid string of close-packed orientation:", zdir
        stop
end select

allocate(ion(nfions))
allocate(zbin(5,nbins))
allocate(tetra(ntet))

hboxlen = boxlen/2.0

zbin = 0

open(11, file=tetlistf, status="old")
open(12, file=posfile, status="old")
open(13, file=tetoccf, status="old", form="unformatted")

write(fmtin, '(A4,I4,A7)') "(I5,",nions,"(I5,X))" ! internal write to define output formatting

do i=1, ntet
    read(11,*) tetra(i)%num(1:4)
enddo

do i=1, nskip-1
    do j=1, nions
        read(12,*) dum, dum, dum
    enddo
    do j=1, nfions
        read(12,*) ion(j)%r(1:3)
    enddo
    read(13)dum, tetra(:)%occupied
enddo

if (dynflag) then
    write(6,*) "initial step"
    do j=1, nions
        read(12,*) dum, dum, dum
    enddo
    do j=1, nfions
        read(12,*) ion(j)%r(1:3)
    enddo
    read(13) dum, tetra(:)%occupied
    tetra(:)%occref = tetra(:)%occupied
    tetra(:)%occold = tetra(:)%occupied
endif

steploop: do i=nskip+1, ncoords
    do j=1, nions
        read(12,*) dum, dum, dum 
    enddo
    do j=1, nfions
        read(12,*) ion(j)%r(1:3)
    enddo
    
    if (dynflag) then
        if (mod(i,nskip) /= 0) then
            read(13) dum, tetra(:)%occdum
            cycle steploop
        endif
    endif
 
    nvac1 = 0
    nocc1 = 0
    nvac2 = 0
    nocc2 = 0
  
    read(13) dum, tetra(:)%occupied

    write(6,*) "step ", i

    if (dynflag) then
        do j=1, ntet
            if (tetra(j)%occupied == tetra(j)%occold) then
                tetra(j)%occref = tetra(j)%occupied
             endif
        enddo
        tetra(:)%occold = tetra(:)%occupied
    else
        tetra(:)%occref = tetra(:)%occupied
    endif

! allocate ion positions to lattice sites

    if (vaclog) then ! only apply periodic boundaries along xz
        kstart = 2
    else
        kstart = 1
    endif
   
    do j=1, ntet
        r1 = ion(tetra(j)%num(1))%r
        r2 = ion(tetra(j)%num(2))%r
        r3 = ion(tetra(j)%num(3))%r
        r4 = ion(tetra(j)%num(4))%r

! enforce periodic boundary conditions
! only for orthorhombic cells at the moment
        if (vaclog) then
            if (r1(1) > vaccent)then
                r1(1) = r1(1) - boxlen(1)
            endif

            if (r2(1) > vaccent)then
                r2(1) = r2(1) - boxlen(1)
            endif

            if (r3(1) > vaccent)then
                r3(1) = r3(1) - boxlen(1)
            endif

            if (r4(1) > vaccent)then
                r4(1) = r4(1) - boxlen(1)
            endif
        endif

        do k=kstart, 3
            tetspread = max(r1(k), r2(k), r3(k), r4(k)) - min(r1(k), r2(k), r3(k), r4(k))
            if (tetspread > hboxlen(k)) then
                if (r1(k) < hboxlen(k)) then 
                    r1(k) = r1(k) + boxlen(k)
                endif
                if (r2(k) < hboxlen(k)) then 
                    r2(k) = r2(k) + boxlen(k)
                endif
                if (r3(k) < hboxlen(k)) then 
                    r3(k) = r3(k) + boxlen(k)
                endif
                if (r4(k) < hboxlen(k)) then 
                    r4(k) = r4(k) + boxlen(k)
                endif
            endif
        enddo
        tetra(j)%ion(1)%r = r1
        tetra(j)%ion(2)%r = r2
        tetra(j)%ion(3)%r = r3
        tetra(j)%ion(4)%r = r4
        
        tetra(j)%centre = (r1+r2+r3+r4)/4
    
        thisbin = int((tetra(j)%centre(zindex) / maxz) * nbins)+1 
        if (thisbin > nbins) then
            thisbin = thisbin - nbins
        endif
        zbin(1,thisbin) = zbin(1,thisbin) + 1
        if (j <= ntet/2) then
            if (tetra(j)%occref == 0) then
                zbin(2,thisbin) = zbin(2,thisbin) + 1
                nvac1 = nvac1 + 1
                write(60,*) "vac1", tetra(j)%centre(:)
             else
                zbin(3,thisbin) = zbin(3,thisbin) + 1
                nocc1 = nocc1 + 1
                write(60,*) "occ1", tetra(j)%centre(:)
            endif
        else
            if (tetra(j)%occref == 0) then
                zbin(4,thisbin) = zbin(4,thisbin) + 1
                nvac2 = nvac2 + 1
                write(60,*) "vac2", tetra(j)%centre(:)
            else
                zbin(5,thisbin) = zbin(5,thisbin) + 1
                nocc2 = nocc2 + 1
                write(60,*) "occ2", tetra(j)%centre(:)
            endif
        endif
    enddo
    write(99,*) i, nvac1, nocc1, nvac2, nocc2
enddo steploop

do i=1, nbins
    write(29,*) i,zbin(:,i)
enddo
end program
