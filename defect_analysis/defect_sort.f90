program defect_sort

! reads the "fort.40" list of occupied tetrahedra generated by defect_new.x
! and reads poscart.out, to produce a z-sliced time average of ion positions
! sorted by sets Td(1), Td(2), and non-assigned ions.

implicit none

type thision
    double precision, dimension(3) :: r
    double precision, dimension(3) :: rref
    integer :: tet
    integer :: tetold
    integer :: tetref
    integer :: tetdum
end type thision

type thistetra
    logical :: occupied
    integer :: pair
end type thistetra

type(thision), allocatable, dimension(:) :: ion
type(thistetra), allocatable, dimension(:) :: tetra
character(len=20) :: inptfile
character(len=20) :: defectfile
character(len=20) :: posfile
character(len=20) :: pairfile
character(len=20) :: outfile1, outfile2, outfile3
character(len=20) :: fmtin
integer :: nbins, ncoords, nions, nfions, ntet
double precision :: maxz
integer :: i, j, dum
integer, allocatable, dimension(:,:) :: zbin
integer :: thisbin, nocc1, nocc2, ndocc, noct
character(len=1) :: zdir
integer :: zindex
integer :: nskip
logical :: dynflag ! only consider defects if present for sequential frames

inptfile = "defect_sort.inpt"
outfile1 = "defectnum.dat"
outfile2 = "defectdist.dat"
outfile3 = "defectpos.dat"

open(99, file=outfile1)
open(28, file=outfile2)
open(60, file=outfile3)
open(10, file=inptfile, status="old")

read(10,*) posfile
read(10,*) defectfile
read(10,*) pairfile
read(10,*) ncoords
read(10,*) nions
read(10,*) nfions
read(10,*) ntet
read(10,*) maxz
read(10,*) nbins
read(10,*) zdir
read(10,*) dynflag
if (dynflag) then
    read(10,*) nskip
else
    nskip = 0
endif

close(10)

allocate(ion(nions))
allocate(zbin(4,nbins))
allocate(tetra(0:ntet))

zbin = 0

select case (zdir)
    case ("x")
        zindex = 1
    case ("y")
        zindex = 2
    case ("z")
        zindex = 3
    case default
        write(6,*) "Not a valid string for close-packed stacking direction"
        stop
end select

open(10, file=pairfile, status="old", form="formatted")
do i=1, ntet
    read(10,*) dum ,j
    tetra(i)%pair = j
enddo

open(11, file=defectfile, status="old", form="unformatted")
open(12, file=posfile, status="old")

write(fmtin, '(A4,I4,A7)') "(I5,",nions,"(I5,X))" ! internal write to define output formatting

do i=1, nskip-1
    do j=1, nions
        read(12,*) ion(j)%r(1:3)
    enddo
    do j=1, nfions
        read(12,*) dum, dum, dum
    enddo
    read(11) dum, ion(:)%tet
enddo

if (dynflag) then
    write(6,*) "initial step"
    do j=1, nions
        read(12,*) ion(j)%rref(1:3)
    enddo
    do j=1, nfions
        read(12,*) dum, dum, dum
    enddo
    read(11) dum, ion(:)%tet
    ion(:)%tetref = ion(:)%tet
    ion(:)%tetold = ion(:)%tet
endif

steploop: do i=nskip+1, ncoords
    do j=1, nions
        read(12,*) ion(j)%r(1:3) 
    enddo
    do j=1, nfions
        read(12,*) dum, dum, dum
    enddo
    
    if (dynflag) then
        if (mod(i,nskip) /= 0) then
            read(11) dum, ion(:)%tetdum
            cycle steploop
        endif
    endif

    read(11) dum, ion(:)%tet

    write(6,*) "step ", i

    !read(11,fmtin) dum, ion(:)%tet

    tetra(:)%occupied = .false.

    if (dynflag) then
        do j=1, nions
            if (ion(j)%tet == ion(j)%tetold) then
                ion(j)%tetref = ion(j)%tet
                ion(j)%rref = ion(j)%r
            endif
        enddo
        ion(:)%tetold = ion(:)%tet
    else
        ion(:)%tetref = ion(:)%tet
        do j=1, nions
            ion(j)%rref = ion(j)%r
        enddo
    endif

    do j=1, nions
        tetra(ion(j)%tetref)%occupied = .true.
    enddo
    tetra(0)%occupied = .false.

    nocc1 = 0
    nocc2 = 0
    noct = 0
    ndocc = 0

    do j=1, nions
        thisbin = int((ion(j)%rref(zindex) / maxz) * nbins)+1 
        if (ion(j)%tetref == 0) then
            zbin(1,thisbin) = zbin(1,thisbin) + 1
            noct = noct + 1
            write(60,*) "oct", ion(j)%rref(:)
        else if (ion(j)%tetref <= ntet/2) then
            zbin(2,thisbin) = zbin(2,thisbin) + 1
            nocc1 = nocc1 + 1
            write(60,*) "tet1", ion(j)%rref(:)
        else
            if (tetra(tetra(ion(j)%tetref)%pair)%occupied) then
                zbin(4,thisbin) = zbin(4,thisbin) + 1
                ndocc = ndocc + 1
                write(6,*) ion(j)%tetref
                write(6,*) tetra(ion(j)%tetref)%pair
                write(6,*) tetra(tetra(ion(j)%tetref)%pair)%occupied
                write(60,*) "tetdd", ion(j)%rref(:)
            else
                zbin(3,thisbin) = zbin(3,thisbin) + 1
                nocc2 = nocc2 + 1
                write(60,*) "tet2", ion(j)%rref(:)
            endif
        endif
    enddo
    write(99,*) i, noct, nocc1, nocc2, ndocc
enddo steploop


do i=1, nbins
    write(28,*) i,zbin(:,i)
enddo
end program
